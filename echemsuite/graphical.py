from __future__ import annotations
from typing import Tuple

from colorsys import rgb_to_hsv, rgb_to_hls, hsv_to_rgb, hls_to_rgb


class Color:
    """
    Simple class encoding the basic properties of a color.

    Arguments
    ---------
    r: float
        The value of the red channel (float between 0 and 1)
    g: float
        The value of the green channel (float between 0 and 1)
    b: float
        The value of the blue channel (float between 0 and 1)
    
    Raise
    -----
    ValueError
        Exception raised if the arguments specified during construction does
        not match the valid color channel values.
    """
    def __init__(self, r: float, g: float, b: float) -> None:
        
        if r<0 or r>1:
            raise ValueError(f"Invalid channel value ({r:.2f}) specified for the red channel. (Must be 0<=r<=1)")
        if g<0 or g>1:
            raise ValueError(f"Invalid channel value ({g:.2f}) specified for the red channel. (Must be 0<=g<=1)")
        if b<0 or b>1:
            raise ValueError(f"Invalid channel value ({b:.2f}) specified for the red channel. (Must be 0<=b<=1)")
        
        self.r: float = r
        self.g: float = g
        self.b: float = b

    @classmethod
    def from_HEX(cls, value: str) -> Color:
        """
        Classmethod capable of constructing an instance of the Color class from an HEX string.

        Arguments
        ---------
        value: str
            The HEX string encoding the RGB colors.
        """
        value = value.lstrip("#")
        lv = len(value)
        rgb = tuple(int(value[i : i + lv // 3], 16) / 255.0 for i in range(0, lv, lv // 3))
        obj = cls(*rgb)
        return obj

    @property
    def RGB(self) -> Tuple[float, float, float]:
        """
        Returns the tuple encoding the RGB values. (0<=value<=1)

        Returns
        -------
        Tuple[float, float, float]
            Returns the tuple encoding the RGB values.
        """
        return (self.r, self.g, self.b)

    @property
    def HEX(self) -> str:
        """
        Returns the HEX string encodes the RGB values.

        Returns
        -------
        str
            The string encoding the HEX representation of the color.
        """
        rgb_byte = tuple(int(255 * i) for i in [self.r, self.g, self.b])
        return "#%02x%02x%02x" % rgb_byte

    def saturate(self) -> Color:
        """
        Saturate the color by setting the saturation channel to 1.

        Returns
        -------
        Color
            An instance of the Color class encoding the saturated color.
        """
        h, _, v = rgb_to_hsv(self.r, self.g, self.b)
        r, g, b = hsv_to_rgb(h, 1.0, v)
        obj = Color(r, g, b)
        return obj


class ColorShader:
    """
    Simple class capable of providing shades of a given base color. The shades of color can be accessed by index
    using the built in __getitem__ method or can be obtained using the built in __iter__ method.

    Arguments
    ---------
    basecolor: Color
        The base color to be used in the generation of the shades
    levels: int
        The number of color levels to be generated by the shader.
    reversed: bool
        If set to True will reverse the order of the color shades.
    saturate: bool
        If set to True will saturate the basecolor given as argument.
    luminance_range: Tuple[float, float]
        The tuple encoding the minimum and maximum luminance values
        (between 0 and 1) used by the shader. (default:(`0.4`, `0.9`))
    
    Raise
    -----
    ValueError
        Exception raised if an invalid number of levels has been provided by the user
        or if the luminance_range is invalid
    """
    def __init__(
        self,
        basecolor: Color,
        levels: int,
        reversed: bool = False,
        saturate: bool = False,
        luminance_range: Tuple[float, float] = (0.4, 0.9)
    ) -> None:
        
        if levels <= 0:
            raise ValueError("The number of levels of the shader must be a non-negative integer.")

        if len(luminance_range) != 2 or luminance_range[0]>luminance_range[1]:
            raise ValueError("The luminance range must be a tuple of length 2 encoding the minimum and maximum values.")
        
        if luminance_range[0]<0 or luminance_range[1] > 1:
            raise ValueError("The luminance limit values must be between 0 and 1.")

        self.basecolor: Color = basecolor if saturate else basecolor.saturate()
        self.levels: int = levels
        self.reversed: bool = reversed
        self.luminance_range: Tuple[float, float] = luminance_range

    def __getitem__(self, index: int) -> Color:
        """
        Get the shade of color corresponding to the user specified `index`.

        Arguments
        ---------
        index: int
            The index of the desired shade of color.
        
        Returns
        -------
        Color
            The Color class object encoding the desired shade.
        """
        if index >= self.levels:
            raise ValueError(f"Index out of bounds. The maximum nuber of steps is {self.levels}")

        h, _, s = rgb_to_hls(*self.basecolor.RGB)

        # Set the maximum or the color luminance to 0.9 and the minimum to 0.3 to avoid full
        # black or full white color shades
        if self.reversed:
            l = 0.4 + 0.5 * (index / (self.levels + 1))
        else:
            l = 0.9 - 0.5 * (index / (self.levels + 1))

        color = Color(*hls_to_rgb(h, l, s))
        return color

    def __iter__(self) -> Color:
        """
        Yields the shades of color endoded in the shader.
        
        Yields
        ------
        Color
            The Color class object encoding the current shade of color.
        """
        for index in range(self.levels):
            yield self[index]
