from __future__ import annotations
from typing import Tuple, List

import matplotlib.pyplot as plt

from palettable.cartocolors.qualitative import Bold_10, Pastel_10, Prism_8, Vivid_10
from palettable.cartocolors.cartocolorspalette import CartoColorsMap
from colorsys import rgb_to_hsv, rgb_to_hls, hsv_to_rgb, hls_to_rgb


class Color:
    """
    Simple class encoding the basic properties of a color.

    Arguments
    ---------
    r: float
        The value of the red channel (float between 0 and 1)
    g: float
        The value of the green channel (float between 0 and 1)
    b: float
        The value of the blue channel (float between 0 and 1)

    Raise
    -----
    ValueError
        Exception raised if the arguments specified during construction does
        not match the valid color channel values.
    """

    def __init__(self, r: float, g: float, b: float) -> None:
        if r < 0 or r > 1:
            raise ValueError(f"Invalid channel value ({r:.2f}) specified for the red channel. (Must be 0<=r<=1)")
        if g < 0 or g > 1:
            raise ValueError(f"Invalid channel value ({g:.2f}) specified for the red channel. (Must be 0<=g<=1)")
        if b < 0 or b > 1:
            raise ValueError(f"Invalid channel value ({b:.2f}) specified for the red channel. (Must be 0<=b<=1)")

        self.r: float = r
        self.g: float = g
        self.b: float = b
    
    def __str__(self) -> str:
        return f"Color({self.r:.2f}, {self.g:.2f}, {self.b:.2f})"

    def __repr__(self) -> str:
        return str(self)

    @classmethod
    def from_HEX(cls, value: str) -> Color:
        """
        Classmethod capable of constructing an instance of the Color class from an HEX string.

        Arguments
        ---------
        value: str
            The HEX string encoding the RGB colors.
        """
        value = value.lstrip("#")
        lv = len(value)
        rgb = tuple(int(value[i : i + lv // 3], 16) / 255.0 for i in range(0, lv, lv // 3))
        obj = cls(*rgb)
        return obj

    @property
    def RGB(self) -> Tuple[float, float, float]:
        """
        Returns the tuple encoding the RGB values. (0<=value<=1)

        Returns
        -------
        Tuple[float, float, float]
            Returns the tuple encoding the RGB values.
        """
        return (self.r, self.g, self.b)

    @property
    def HEX(self) -> str:
        """
        Returns the HEX string encodes the RGB values.

        Returns
        -------
        str
            The string encoding the HEX representation of the color.
        """
        rgb_byte = tuple(int(255 * i) for i in [self.r, self.g, self.b])
        return "#%02x%02x%02x" % rgb_byte

    def saturate(self) -> Color:
        """
        Saturate the color by setting the saturation channel to 1.

        Returns
        -------
        Color
            An instance of the Color class encoding the saturated color.
        """
        h, _, v = rgb_to_hsv(self.r, self.g, self.b)
        r, g, b = hsv_to_rgb(h, 1.0, v)
        obj = Color(r, g, b)
        return obj


class ColorShader:
    """
    Simple class capable of providing shades of a given base color. The shades of color can be accessed by index
    using the built in __getitem__ method or can be obtained using the built in __iter__ method.

    Arguments
    ---------
    basecolor: Color
        The base color to be used in the generation of the shades
    levels: int
        The number of color levels to be generated by the shader.
    reversed: bool
        If set to True will reverse the order of the color shades.
    saturate: bool
        If set to True will saturate the basecolor given as argument.
    luminance_range: Tuple[float, float]
        The tuple encoding the minimum and maximum luminance values
        (between 0 and 1) used by the shader. (default:(`0.4`, `0.9`))

    Raise
    -----
    ValueError
        Exception raised if an invalid number of levels has been provided by the user
        or if the luminance_range is invalid
    """

    def __init__(
        self,
        basecolor: Color,
        levels: int,
        reversed: bool = False,
        saturate: bool = False,
        luminance_range: Tuple[float, float] = (0.4, 0.9),
    ) -> None:
        if levels <= 0:
            raise ValueError("The number of levels of the shader must be a non-negative integer.")

        if len(luminance_range) != 2 or luminance_range[0] > luminance_range[1]:
            raise ValueError("The luminance range must be a tuple of length 2 encoding the minimum and maximum values.")

        if luminance_range[0] < 0 or luminance_range[1] > 1:
            raise ValueError("The luminance limit values must be between 0 and 1.")

        self.basecolor: Color = basecolor if saturate else basecolor.saturate()
        self.levels: int = levels
        self.reversed: bool = reversed
        self.luminance_range: Tuple[float, float] = luminance_range

    def __getitem__(self, index: int) -> Color:
        """
        Get the shade of color corresponding to the user specified `index`.

        Arguments
        ---------
        index: int
            The index of the desired shade of color.

        Returns
        -------
        Color
            The Color class object encoding the desired shade.
        """
        if index >= self.levels:
            raise ValueError(f"Index out of bounds. The maximum nuber of steps is {self.levels}")

        h, _, s = rgb_to_hls(*self.basecolor.RGB)

        # Set the maximum or the color luminance to 0.9 and the minimum to 0.3 to avoid full
        # black or full white color shades
        if self.reversed:
            l = 0.4 + 0.5 * (index / (self.levels + 1))
        else:
            l = 0.9 - 0.5 * (index / (self.levels + 1))

        color = Color(*hls_to_rgb(h, l, s))
        return color

    def __iter__(self) -> Color:
        """
        Yields the shades of color endoded in the shader.

        Yields
        ------
        Color
            The Color class object encoding the current shade of color.
        """
        for index in range(self.levels):
            yield self[index]


class Palette:
    """
    A simple palette class capable of providing to the user different types color sequences.
    The __len__ attribute of the object is set as the length of the color sequence. The __getitem__
    method allows the user to access the sequence of colors. If the index of the color exceeds the
    number of colors in the sequence the color provided will loop around the list.

    The available palettes are: `matplotlib`, `bold`, `pastel`, `prism`, `vivid`

    Arguments
    ---------
    palette: str
        The name of the palette to be used.
    """
    def __init__(self, palette: str) -> None:
        if palette == "matplotlib":
            colors = [Color.from_HEX(c) for c in plt.rcParams["axes.prop_cycle"].by_key()["color"]]

        elif palette in ["bold", "pastel", "prism", "vivid"]:

            if palette == "bold":
                colors = [Color(*[c/255 for c in color]) for color in Bold_10.colors]

            elif palette == "pastel":
                colors = [Color(*[c/255 for c in color]) for color in Pastel_10.colors]

            elif palette == "prism":
                colors = [Color(*[c/255 for c in color]) for color in Prism_8.colors]

            elif palette == "vivid":
                colors = [Color(*[c/255 for c in color]) for color in Vivid_10.colors]

        else:
            raise ValueError(f"The color palette {palette} is not supported.")

        self.color_sequence: List[Color] = colors
    
    def __len__(self) -> int:
        return len(self.color_sequence)

    def __getitem__(self, index: int) -> Color:
        idx = index % len(self)
        return self.color_sequence[idx]
